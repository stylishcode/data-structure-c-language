/*
INICIAR LISTA:
    - FAZER O INICIO APONTAR PARA NULO (COM PONTEIRO)
*/
/*
INSERIR NO INICIO:
    - CRIAR UM NOVO TIPO NO
    - ALOCAR MEMORIA PRA ESSE NOVO NO
    - CAMPO DADO DESSE NOVO NO RECEBE O VALOR QUE SE DESEJA INSERIR
    - VERIFICAR SE A LISTA ESTÁ VAZIA, SE SIM, O PROXIMO DE NOVO APONTA PARA NOVO (APONTA PRA ELE MESMO)
    - SENAO, PROXIMO DE NOVO APONTA PARA O PRIMEIRO DA LISTA 
    - CRIAR NOVO NO AUX RECEBE PRIMEIRO DA LISTA
    - ENQUANTO O PROXIMO DE AUXILAR NÃO FOR O PRIMEIRO DA LISTA 
    - AUX RECEBE PROXIMO DE AUX 
    -FIM ENQUANTO
    - PROXIMO DE AUX RECEBE NOVO (PARA DE APONTAR PRO ANTIGO NO QUE ERA PRIMEIRO DA LISTA E APONTA PRO NOVO NO)
    - FORA DO ELSE, PRIMEIRO DA LISTA RECEBE NOVO (PASSA A SER RECONHECIDO COMO O PRIMEIRO DA LISTA)
    - NO FINAL O NOVO ELEMENTO PASSA A SER RECONHECIDO COMO PRIMEIRO, ISSO DIFERENCIA A INSERÇÃO DO INICIO PARA O NO FIM.
*/
/*
INSERIR NO FINAL*/
    - CRIAR UM NOVO TIPO NO
    - ALOCAR MEMORIA PRA ESSE NOVO NO
    - CAMPO DADO DESSE NOVO NO RECEBE O VALOR QUE SE DESEJA INSERIR
    - VERIFICAR SE A LISTA ESTÁ VAZIA, SE SIM, O PROXIMO DE NOVO APONTA PARA NOVO (APONTA PRA ELE MESMO)
    - PRIMEIRO DA LISTA APONTA PARA NOVO
    - SENAO:
    - CRIAR NOVO NO AUX RECEBE PRIMEIRO DA LISTA
    - ENQUANTO O PROXIMO DE AUXILAR NÃO FOR O PRIMEIRO DA LISTA 
    - AUX RECEBE PROXIMO DE AUX 
    -FIM ENQUANTO
    - PROXIMO DE AUX RECEBE NOVO (PARA DE APONTAR PRO ANTIGO NO QUE ERA PRIMEIRO DA LISTA E APONTA PRO NOVO NO)
    - PROXIMO DE NOVO PASSA A APONTAR PARA O PRIMEIRO DA LISTA
    - NO FINAL O NOVO ELEMENTO, QUE É O ÚLTIMO, O PROXIMO DELE APONTA PARA O PRIMEIRO. ISSO DIFERENCIA A INSERÇÃO DO FIM PARA NO INICIO
/*
BUSCAR:
    - SE O PRIMEIRO DA LISTA NÃO FOR NULO :
    - CRIAR NO AUX COM INDICE DO PRIMEIRO DA LISTA 
    - CRIAR VARIAVEL QUE ARMAZENE 1 PARA TRUE E 0 PARA FALSE
    - FAÇA:
    - IF DADO DE AUX FOR O VALOR QUE PROCURAMOS, VARIAVEL RECEBE 1, SENAO, AUX PASSA PARA O PROXIMO DE AUX
    - ENQUANTO AUX FOR DIFERENTE DO PRIMEIRO DA LISTA E VARIAVEL FOR 0 (FIM FAÇA)
    - SE VARIAVEL FOR 1, MOSTRAR VALOR ENCONTRADO, SENAO, MOSTRAR VALOR INEXISTENTE
    - FIM DE SE NÃO FOR NULO 
*/
/*
REMOVER INICIO:
    - SE O PRIMEIRO DA LISTA NÃO FOR NULO
    - (dentro do se) SE O PROXIMO DO PRIMEIRO DA LISTA FOR NULO
    - CRIAR NO AUX COM INDICE DO PRIMEIRO DA LISTA
    - LIBERAR AUX
    - SENAO
    - CRIAR NO AUX COM INDICE DO PRIMEIRO
    - CRIAR NO pAUX COM INDICE DO PROX DE AUX
    - CRIAR NO ULTIMO = NULL;
    - ENQUANTO P NÃO FOR AUX (P APONTA EM AUX E NAO NO PROX DE AUX!! DA A VOLTA NA LISTA)
    - SE PROX DE P FOR AUX, ULTIMO RECEBE P (COM P DANDO A VOLTA, SE O PROX DELE FOR O AUX), SENAO P RECEBE PROXIMO DE P
    - FORA DO SENAO 
    - PRIMEIRO DA LISTA RECEBE PROX DE AUX (PRIMEIRO DA LISTA PASSA A APONTAR PRO SEGUNDO ELEMENTO (QUE ERA PROX DE AUX))
    - PROX DE ULTIMO RECEBE PRIMEIRO DA LISTA (E O ULTIMO APONTA PARA O PRIMEIRO, EXCLUINDO AUX, QUE ERA O ANTIGO PRIMEIRO)
    - LIBERAR AUX 
*/
/*
REMOVER FINAL:
    VERIFICAR SE A LISTA ESTÁ VAZIA, SE SIM, NÃO TEM QUE O REMOVER, SAIR DO PROGRAMA
    SENÃO:
    SE PRIMEIRO DA LISTA FOR DIFERENTE DE NULL
    SE PROXIMO DO PRIMEIRO DA LISTA FOR IGUAL AO PRIMEIRO DA LISTA (SE O PRIMEIRO APONTA PRA ELE MESMO)
    CRIAR NO AUX QUE RECEBE O PRIMEIRO DA LISTA
    LIBERAR AUX
    PRIMEIRO DA LISTA RECEBE NULL
    SENAO:
    CRIAR NO AUX QUE RECEBE COMO INDICE O PRIMEIRO DA LISTA
    CRIAR NO ANTERIOR QUE RECEBE NULL
    ENQUANTO PROXIMO DE AUX FOR DIFERENTE DO PRIMEIRO DA LISTA (COMO LISTA CIRCULAR, ULTIMO ELEMENTO É O PRIMEIRO DA LISTA)
    ANTERIOR RECEBE AUX (GUARDA O ENDEREÇO DO PENULTIMO ELEMENTO DA LISTA)
    AUX RECEBE PROXIMO DE AUX
    FORA DO ENQUANTO, LIBERAR AUX
    PROX DE ANTERIOR RECEBE PRIMEIRO DA LISTA (PENULTIMO PASSA A SER O ULTIMO DA LISTA)
*/
